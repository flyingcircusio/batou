Quickstart
==========

Do you want to get started? We'll go through the steps of developing a project
with batou. The steps are built on top of each other, so if you have trouble
with a specific step, it might help to review what happened earlier.

Create a new project
--------------------

Deployments with batou are placed in a new directory. For this tutorial
we will assume that you're using git as your version control system. Feel
feel free to follow along using Mercurial -- batou can handle both.

.. code-block:: console

  $ mkdir myproject
  $ cd myproject
  $ curl https://batou.readthedocs.org/en/latest/batou -o batou
  $ chmod +x batou
  $ git init
  $ git add batou
  $ git commit
  $ ./batou
  Preparing virtualenv in .batou ...
  Pre-installing batou - this can take a while...
  Installing Jinja2==2.7.3
  Installing requests==2.6.0
  Installing setuptools==18.3.1
  Installing execnet==1.3.0
  Installing py==1.4.26
  usage: batou [-h] [-d] [-F] {deploy,remote,secrets,init,update} ...
  batou: error: too few arguments

The project is now initialized and batou is ready to be used.

Writing a component configuration
---------------------------------

Once you bootstrapped your batou project you start modelling your
configuration. This is done by creating a directory in the ``components``
directory and a ``component.py`` file in there. You can use those sub-
directories to group together things that belong to each component:

.. code-block:: shell

  $ cd myproject
  $ mkdir -p components/myapp

In ``components/myapp/component.py`` put the following to manage a very
simple application:

.. code-block:: python
  :caption: components/myapp/component.py

  from batou.component import Component
  from batou.lib.file import File


  class Tick(Component):

      def configure(self):
          self += File(
              'tick.sh',
              mode=0755,
              content="""\
  while true; do
    date
    sleep 1
  done
  """)

The component has a ``configure`` method that is used to build a model of your
configuration as a tree of components. By using the syntax ``self += File(...)``
you add a File component as a sub-component to your Tick component. Components
can thus recursively combine configurations into larger, more complex setups.

The order of sub-components is given by the order they are added to their
parent.

Local environments
------------------

Now, to deploy this "application" we can specify a local environment to deploy
directly on the machine you are working on:

.. code-block:: shell

  $ mkdir environments

Put the following in ``environments/local.cfg`` to specify a local
configuration that will deploy the "Tick" component:

.. code-block:: ini
  :caption: environments/local.cfg

  [environment]
  connect_method = local

  [hosts]
  localhost = tick

Your project now looks like this:

.. code-block:: console

  $ tree
  .
  ├── batou
  ├── components
  │   └── myapp
  │       └── component.py
  └── environments
      └── local.cfg

You can now deploy this environment:

.. code-block:: console

  $ ./batou deploy local
  ============================== Preparing ===============================
  main: Loading environment `local`...
  main: Verifying repository ...
  main: Loading secrets ...
  ======================= Configuring first host =========================
  localhost: Connecting via local (1/1)
  ===================== Connecting remaining hosts =======================
  ============================== Deploying ===============================
  localhost: Deploying component tick ...
       Tick > File(work/tick/tick.sh) > Presence(work/tick/tick.sh)
       Tick > File(work/tick/tick.sh) > Mode(work/tick/tick.sh)
       Tick > File(work/tick/tick.sh) > Content(work/tick/tick.sh)
  ========================= DEPLOYMENT FINISHED ==========================

When deploying, batou creates a working directory for each component. Your
project directory now looks like this:

.. code-block:: console

  $ tree
  .
  ├── batou
  ├── components
  │   └── myapp
  │       └── component.py
  ├── environments
  │   └── local.cfg
  └── work
      └── tick
          └── tick.sh

The application has been copied over to the work directory and the mode has
been set. We can now use it:

.. code-block:: console

  $ ./work/tick/tick.sh
  Thu Jan 28 21:47:58 CET 2016
  Thu Jan 28 21:47:59 CET 2016
  Thu Jan 28 21:48:00 CET 2016
  Thu Jan 28 21:48:01 CET 2016
  Thu Jan 28 21:48:02 CET 2016
  Thu Jan 28 21:48:03 CET 2016
  ^C

When running the deployment again, you see that batou knows what has been
deployed and that no action is necessary:

.. code-block:: console

  $ ./batou deploy local
  batou/1.2b1 (CPython 2.7.10-final0, Darwin 15.3.0 x86_64)
  ============================== Preparing ===============================
  main: Loading environment `local`...
  main: Verifying repository ...
  main: Loading secrets ...
  ======================= Configuring first host =========================
  localhost: Connecting via local (1/1)
  ===================== Connecting remaining hosts =======================
  ============================== Deploying ===============================
  localhost: Deploying component tick ...
  ========================= DEPLOYMENT FINISHED ==========================

.. note::

  Things in the work directory are generated or data from your application --
  you should thus add the ``work`` directory to your version control systems'
  ignore file.


Vagrant environments
--------------------

If you would like to deploy a more complex application, that may involve
a webserver, databases, and other auxiliary services, you may prefer to
deploy into a virtual machine, instead of deploying those to your local
work environment.

For this, batou supports `Vagrant <http://vagrantup.com>`_. Once you have
Vagrant (and VirtualBox) installed, place a `Vagrantfile` directory in
your batou project:

.. code-block:: ruby
  :caption: Vagrantfile

  # -*- mode: ruby -*-
  # vi: set ft=ruby :

  Vagrant.configure("2") do |config|
    config.vm.box = "flyingcircus/nixos-15.09-x86_64"
    config.vm.box_version = ">= 1.2"

    config.vm.network "private_network", ip: "192.168.50.4"
    config.vm.hostname = "default"
  end

Now, we add a second environment that uses Vagrant to connect and rsync
to ensure that our batou project gets synced. The user we want to deploy
to in a vagrant box is `vagrant` and we specify that as the service user.
The machine in our Vagrant file is "default", so we use that as the hostname:

.. code-block:: ini
  :caption: environments/vagrant.cfg

  [environment]
  connect_method = vagrant
  update_method = rsync
  service_user = vagrant

  [hosts]
  default = tick

The deployment is invoked similar to the local deployment. Getting the
vagrant machine up and running may take a while, though:

.. code-block:: console

  $ ./batou deploy vagrant
  batou/1.2b1 (CPython 2.7.10-final0, Darwin 15.3.0 x86_64)
  =========================== Preparing ============================
  main: Loading environment `vagrant`...
  main: Verifying repository ...
       You are using rsync. This is a non-verifying repository --
       continuing on your own risk!
  main: Loading secrets ...
  ===================== Configuring first host =====================
  vagrant: Ensuring machines are up ...
  default: Connecting via vagrant (1/1)
  =================== Connecting remaining hosts ===================
  =========================== Deploying ============================
  default: Deploying component tick ...
       Tick > File(work/tick/tick.sh) > Presence(work/tick/tick.sh)
       Tick > File(work/tick/tick.sh) > Mode(work/tick/tick.sh)
       Tick > File(work/tick/tick.sh) > Content(work/tick/tick.sh)
  ====================== DEPLOYMENT FINISHED =======================

Now, the tick component has been deployed on the virtual machine. We can
connect there and see that the same structure has been deployed as previously
for our local environment. batou places deployments in the service user's
home directory in a directory named `deployment` by default:

.. code-block:: console

  $ vagrant ssh
  [vagrant@nixos:~]$ tree
  .
  └── deployment
      ├── batou
      ├── components
      │   └── myapp
      │       └── component.py
      ├── environments
      │   ├── local.cfg
      │   └── vagrant.cfg
      ├── Vagrantfile
      └── work
          └── tick
              └── tick.sh
  [vagrant@nixos:~]$ ./deployment/work/tick/tick.sh
  Thu Jan 28 21:02:31 UTC 2016
  Thu Jan 28 21:02:32 UTC 2016
  Thu Jan 28 21:02:33 UTC 2016
  ^C


Remote environments
-------------------

To deploy your application into a production environment you will typically
use SSH to log in to the remote servers. This works similar to Vagrant
environments. To try this out, you will have to replace the host name you
see here, with a host that you have access to.

.. note::

  Make sure that the few but important
  :any:`installation requirements <install>` requirements for remote hosts
  are satisfied!

Let's add a third environment that uses SSH to connect and rsync
to ensure that our batou project gets synced. We do not specify the user to
deploy to, which means batou will use whatever your SSH configuration is set
up to use. To save some typing (and for some other features) we specify
a domain name that should be appended to all hosts.

Here's the full environment configuration:

.. code-block:: ini
  :caption: environments/production.cfg

  [environment]
  connect_method = ssh
  update_method = rsync
  host_domain = fcio.net

  [hosts]
  test01 = tick

Now, to deploy to the remote host:

.. code-block:: console

  $ ./batou deploy production
  batou/1.2b1 (CPython 2.7.10-final0, Darwin 15.3.0 x86_64)
  =========================== Preparing ============================
  main: Loading environment `production`...
  main: Verifying repository ...
       You are using rsync. This is a non-verifying repository --
       continuing on your own risk!
  main: Loading secrets ...
  ===================== Configuring first host =====================
  test01: Connecting via ssh (1/1)
  =================== Connecting remaining hosts ===================
  =========================== Deploying ============================
  test01.gocept.net: Deploying component tick ...
       Tick > File(work/tick/tick.sh) > Presence(work/tick/tick.sh)
       Tick > File(work/tick/tick.sh) > Mode(work/tick/tick.sh)
       Tick > File(work/tick/tick.sh) > Content(work/tick/tick.sh)
  ====================== DEPLOYMENT FINISHED =======================


Overriding configuration per environment
----------------------------------------

Every environment is currently deploying the same configuration of our
application. It often is necessary to customize applications based on the
environment: either your setup is larger or smaller, or you are using
a different web address to access it, or ...

To make a component configurable, we add an attribute to the component
class:

.. code-block:: python
  :caption: components/myapp/component.py

  from batou.component import Component, Attribute
  from batou.lib.file import File


  class Tick(Component):

      sleep = Attribute(int, 1)

      def configure(self):
          self += File(
              'tick.sh',
              mode=0755,
              content="""\
  while true; do
    date
    sleep {}
  done
  """.format(self.sleep))

Attributes are specified with a conversion function or type, to help batou
convert them from strings. The second argument given is the default that will
be used when attribute is not specified explicitly otherwise. The attribute
can then be accessed as usual during the configure method and include this in
our application configuration.

To adjust the application for the development environment, we add a new
section ``[component:tick]`` to the configuration:

.. code-block:: ini
  :caption: environments/local.cfg

  [environment]
  connect_method = local

  [hosts]
  localhost = tick

  [component:tick]
  sleep = 10

Now, let's deploy this:

.. code-block:: shell

  $ ./batou deploy local
  batou/1.2b1 (CPython 2.7.10-final0, Darwin 15.3.0 x86_64)
  =========================== Preparing ============================
  main: Loading environment `local`...
  main: Verifying repository ...
  main: Loading secrets ...
  ===================== Configuring first host =====================
  localhost: Connecting via local (1/1)
  =================== Connecting remaining hosts ===================
  =========================== Deploying ============================
  localhost: Deploying component tick ...
       Tick > File(work/tick/tick.sh) > Content(work/tick/tick.sh)
  ====================== DEPLOYMENT FINISHED =======================

  $ cat work/tick/tick.sh
  while true; do
    date
    sleep 10
  done

  $ ./work/tick/tick.sh
  Fri Jan 29 09:44:18 CET 2016
  Fri Jan 29 09:44:28 CET 2016
  ^C

Now, our model specific the default configuration and environment-specific
overrides allow us to document variations between environments easily.

Templating from files
---------------------

Currently our application configuration has been written directly in Python
code. This quickly becomes unwieldy. File components can be used to pull their
content from files by specifying the ``source`` parameter. The filename is
relative to the directory that the ``component.py`` is placed in:

.. code-block:: python
  :caption: components/myapp/component.py

  from batou.component import Component
  from batou.lib.file import File


  class Tick(Component):

      def configure(self):
          self += File(
              'tick.sh',
              mode=0755,
              source='tick.sh')

Also, templating with Python format strings is very limited. batou thus
includes Jinja2 templating, which is enabled by default for all content
(independent of whether you specify the content inline or in a separate file).

.. code-block:: bash
  :caption: components/myapp/tick.sh
  #!/bin/bash
  while true; do
    date
    sleep {{component.sleep}}
  done

As a simplification, you can leave out the ``source`` parameter if the
filename of your template is identical to the name you want it to be in the
work directory:


.. code-block:: python
  :caption: components/myapp/component.py

  from batou.component import Component
  from batou.lib.file import File


  class Tick(Component):

      def configure(self):
          self += File('tick.sh', mode=0755)

To disable templating and encoding handling, you can use the ``BinaryFile``
component::

.. code-block:: python
  from batou.component import Component, Attribute
  from batou.lib.file import File

  class Example(Component):

      def configure(self):
          self += BinaryFile('something.zip')


Storing secrets as encrypted overrides
--------------------------------------


Using version control to ensure consistent deployments
------------------------------------------------------


Downloading and building software
---------------------------------


Managing Python environments
----------------------------


Registering programs with supervisor
------------------------------------


Working with network addresses
------------------------------


Registering and discovering services
------------------------------------


Updating batou in an existing project
-------------------------------------

Checking a deployment configuration before running it
-----------------------------------------------------

Platform-specific components
----------------------------
